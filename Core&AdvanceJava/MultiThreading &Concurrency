1. What is multithreading in Java?
-> Multithreading is the concurrent execution of two or more threads. It allows Java programs to perform multiple tasks
   simultaneously, improving CPU utilization.

2. Difference between process and thread.
-> Process: Independent execution unit with its own memory space. Heavyweight.
   Thread: Lightweight sub-unit of a process, shares memory with other threads in the same process.

3. How do you create a thread in Java?
-> By extending Thread class and overriding run().
   By implementing Runnable interface and passing it to a Thread object.
   By using Executors / Callable / Future (modern way).

4. Difference between extending Thread class and implementing Runnable.
-> Thread: Can’t extend any other class (since Java allows single inheritance).
   Runnable: More flexible, preferred, allows implementing multiple interfaces.
   Runnable method is mostly preferable as it provides better reusability and flexibility.

5. What is the difference between start() and run()?
-> start() - Present in Thread class, Creates a new thread and then calls run() on it.
             It runs run() in a separate thread
   run() - It is a method present in Runnable interface, run() in the current thread

6. What happens if you call run() method directly?
-> It will execute as a method in main thread, not of any new thread.

7. What is thread lifecycle in Java?
->  NEW   -->   RUNNABLE   -->   RUNNING   -->   TERMINATED
                  ^     |              |
                  |     v              v
                WAITING / TIMED_WAITING / BLOCKED

8. Difference between daemon thread and user thread.
-> User Thread = The default type of thread in Java. Keeps the JVM alive until all user threads have finished.
   Daemon Thread = A background service thread that provides support to user threads.JVM does not wait for daemon
threads to finish; it exits as soon as all user threads are done.Used for tasks like garbage collection, logging, etc.

9. What is the default priority of a thread?
->  Every Java thread has a priority, which helps the Thread Scheduler decide which thread to run first.
    Priority is an integer value between 1 and 10: Thread.MIN_PRIORITY = 1, NORM_PRIORITY = 5, MAX_PRIORITY = 10

10. Can we change thread priority in Java?
->  Yes, we can change thread priority using setPriority(int) method but actual scheduling depends on OS.

11. What is thread scheduler in Java?
->  The Thread Scheduler is part of the JVM + Operating System that decides which thread runs at any given time when
multiple threads are in the Runnable state. We cannot control it directly in any way.

12. Difference between time slicing and preemptive scheduling.
-> In preemptive scheduling, the highest-priority thread always runs first.If a new thread with higher priority becomes
ready, it preempts (interrupts) the currently running thread. Thread execution order depends mostly on priority.
Time Slicing - CPU time is divided into small time slices (quantum). Each thread gets a fair share of CPU for its time
slice. After its time expires, the next thread gets CPU, even if the current thread is not finished. Execution rotates
in a round-robin fashion

12. What is the purpose of sleep() method in Thread?
->  sleep() method is used to pause thread from running for specified amount of time and move it to the waiting state,
but it didn't release lock. Ex- t1.sleep(2000) -> pause for 2 sec.

13. Difference between sleep() and wait().
->  sleep(): Used to pause execution for a fixed time; does not release the lock.
    wait(): Used for communication between threads; releases the lock and waits until another thread notifies it.

14. Can we call wait() without synchronization?
-> No, wait() is used for inter-thread communication and must release the monitor lock,so it requires the calling thread
to own the lock (synchronized block), otherwise IllegalMonitorStateException occurs
We can call sleep() without synchronization as it only pauses the current thread and doesn’t deal with
object locks, so no synchronization is required.

15. Difference between wait(), notify(), and notifyAll().
->  wait() -> Makes current thread wait.
    notify() -> Wakes up one waiting thread.
    notifyAll() -> Wakes up all waiting threads.

16. What happens if a thread calls wait() and never gets notified?
->  If a thread calls wait() and no other thread ever calls notify() or notifyAll() on the same object, that thread will
remain in the WAITING state forever, effectively getting stuck. To avoid this, best practices are to use wait(timeout)
or always call wait() inside a loop that checks a condition, ensuring the thread does not wait indefinitely.

17. Can notify() wake up multiple threads?
->  No, notify() wakes up exactly one thread that is waiting on the object's monitor. If multiple threads are waiting,
the thread scheduler (JVM) decides which single thread to wake. You cannot control which thread gets chosen.

18. Difference between synchronized method and synchronized block.
->  Synchronized Method → when the entire method is critical (e.g., updating a shared counter). It is more flexible
    Synchronized Block → when only part of the method needs synchronization (e.g.,logging can be outside, but data update inside).

19. What is the use of volatile keyword?
->  The volatile keyword in Java is used to mark a variable so that:
    Its value is always read from main memory (not from CPU cache).Its updates are always written directly to main memory.
    Volatile keyword guarantees visibility of changes across threads, but not atomicity.(Atomicity means: an operation
    happens as a single indivisible step — no other thread can see it half-done.)

20. Difference between volatile and synchronized.
->  As mentioned above that volatile keyword only provide visibility, not atomicity. So synchronized keyword provides
    both.
    volatile keyword is only used for static & instance variable whereas synchronized is used for method or block of cde.
 volatile - no lock involved, faster(no lock overhead) & non -blocking(threads don’t wait).
 Synchronized - Requires a lock (monitor), Slower (threads may block, context switching) & Blocking (one thread at a time can hold the lock)

21. What is the happens-before relationship in Java Memory Model?
->

22. What are atomic operations in Java?
->  An atomic operation is one that is performed as a single, indivisible step:
    Either it happens completely, or it doesn’t happen at all. No other thread can see it in an intermediate (half-done) state.
Compound operations (++, +=) are not atomic. Use synchronized or Atomic classes for atomic compound operations.

23. What is the difference between AtomicInteger and synchronized int?
->
24. What is deadlock in Java?
->  Deadlock means two or more threads are blocked forever, waiting for each other to release resources.
Ex - Thread1 has locked resource1 and now waiting for resource2 to get unlocked.
Similarly, Thread2 has locked resource2 and now waiting for resource1 to get unlocked.
Now this is what deadlock is.

25. How do you avoid deadlock?
-> Strategies to prevent deadlock are -
a. Lock Ordering (Most Common) -> Always acquire locks in a fixed, global order. If all threads follow the same order,
circular wait can’t happen.
b. Try-Lock with Timeout -> Instead of blocking indefinitely, use tryLock() from ReentrantLock with a timeout.
If a lock isn’t acquired, release any held locks and retry.
c. Avoid Nested Locks -> Try to design code to acquire only one lock at a time.
d. Try to use thread safe data structure.

26. What is livelock?
->  A livelock is similar to a deadlock, but here threads are not blocked – instead, they keep changing their state
    in response to each other and never make progress.
So in livelock:
Threads are active (not stuck like in deadlock).
But they are not progressing towards completion

27. What is starvation in multithreading?
->  Starvation happens when a thread is ready to run, but it is continuously denied CPU access because higher-priority
threads (or other resource-holding threads) keep getting scheduled.
To prevent starvation - a. Use reentrant lock. b. Avoid assigning all work to priority thread.

28. Difference between deadlock, livelock, and starvation.
->  DeadLock -  Two or more threads are blocked forever, waiting for each other’s resources.
                Threads state: Blocked, not running.
                CPU usage: 0% (they’re stuck).
                Cause: Circular wait (A waits for B, B waits for A).

    LiveLock -  Two or more threads keep responding to each other and changing their states, but they never make progress.
                Threads state: Running, but uselessly.
                CPU usage: High (threads actively running).
                Cause: Excessive yielding / backing off

    Starvation - A thread is ready to run but is continuously denied CPU or resources because others dominate them.
                 Threads state: Waiting indefinitely for CPU or resource.
                 CPU usage: Depends (other threads are hogging CPU).
                 Cause: Unfair scheduling or priority inversion.

29. What is the difference between concurrency and parallelism?
->  Concurrency - It's about dealing with multiple tasks at once, but not necessarily running them at the same exact time.
    Think of it as task switching: a system interleaves execution of tasks, giving the illusion they progress simultaneously.
    Goal: Manage multiple tasks efficiently (fairness, responsiveness).
    Example: On a single-core CPU: running multiple threads concurrently means the CPU switches between them quickly
    (context switching).
    In Java: using multiple threads with ExecutorService — even if only one core exists, tasks appear concurrent.

    Parallelism - Parallelism is about actually executing multiple tasks simultaneously, typically using multiple CPU cores.
    Goal: Speed up execution by doing work in parallel.
    Example: On a quad-core CPU: processing four data chunks simultaneously.
    In Java: ForkJoinPool splitting tasks across available cores.

30. What is ThreadLocal in Java?
->  ThreadLocal<T> is a special class in Java that provides thread-local variables.
    Each thread that accesses a ThreadLocal variable has its own independent copy of that variable, that means values
    stored in a ThreadLocal are not shared between threads.

31. When should we use ThreadLocal?
->  Use ThreadLocal when you need thread-confined state, such as user/session data, database connections, or
non-thread-safe utilities, where synchronization would otherwise be needed.

32. What is the difference between Callable and Runnable?
->  Runnable → when your task just executes code without returning anything (logging, updating cache, sending notification).
    Callable → when your task needs to return a result or throw checked exceptions (e.g., fetching data, calculating a value).

33. What is Future in Java concurrency?
->

34. What is ExecutorService in Java?
->  ExecutorService is an interface in java.util.concurrent package.It represents a thread pool manager that handles
and controls multiple threads for you. Instead of creating and managing threads manually (new Thread(...)),
you submit tasks (Runnable or Callable) to an ExecutorService.
In short: It decouples task submission from thread management.

35. Difference between submit() and execute() in ExecutorService.
->

36. What is ScheduledExecutorService?
->

37. How do you shut down ExecutorService?
->

38. Difference between shutdown() and shutdownNow().
-> 

39. What is ForkJoinPool in Java?
->

40. Difference between ForkJoinPool and ThreadPoolExecutor.
->

41. What is the join() method in threads?
->  join() makes the current thread wait until the thread on which join() is called finishes execution.
Ex t1.join() here means main thread will wait, until and unless the t1 thread doesnot changed it state from running to
terminated.

42. What is the yield() method in threads?
-> It moves the thread from the Running state back to the Runnable state. The thread scheduler may then decide to let
another thread run (especially one of the same priority). If no other thread of the same priority is waiting, the current
thread may continue execution.
As choosing the next thread behaviour is platform and JVM dependent, so it is not sure that it will follow fairness.

43. Difference between yield() and sleep().
->  yield() → Hint to the scheduler: “I’m ready to pause, let other threads of the same priority run.”
    Moves the current thread from Running → Runnable state. Scheduler may immediately pick it again → no guarantee of pause.
    No checked exception. It take place for very short period of time or  possibly zero — depends on scheduler.

    sleep(ms) → Force the current thread to pause for a specified duration (milliseconds or nanoseconds).
    Moves the current thread to Timed Waiting state. Guaranteed to pause for at least the given time.
    Must handle or declare InterruptedException. We can make thread sleep for any period of time.

44. What is the difference between interrupt() and stop()?
->  The stop() method forcibly terminates a thread, immediately stopping its execution at any point.
    It is considered unsafe and has been deprecated since Java 2. This is because stop() can lead to inconsistent object
    states and resource leaks. When a thread is abruptly stopped, it doesn't get a chance to clean up resources, release
    locks, or complete ongoing operations.

    Thread.interrupt():
    The interrupt() method does not immediately stop a thread. Instead, it sets an "interrupted" flag on the target thread.
    he interrupted thread is then responsible for checking this flag periodically (using Thread.isInterrupted()) or
    handling InterruptedException if it's in a blocking operation like Thread.sleep(), Object.wait(), or I/O operations.
    This cooperative approach allows the thread to gracefully shut down, clean up resources, and maintain data consistency
    before terminating its execution.

45. Why is stop() deprecated in Java?
->  The Thread.stop() method in Java was deprecated because it’s inherently unsafe
- When stop() is called, it forces the thread to terminate immediately and releases all the locks (monitors) it holds.
If the thread was in the middle of updating shared data, other threads might see that data in a corrupted or
inconsistent state.

46. What is the ReentrantLock class?
->  A ReentrantLock allow threads to enter into lock on a resource more than once. When the thread first enters into lock,
a hold count is set to one. Before unlocking the thread can re-enter into lock again and every time hold count is incremented
by one. For every unlock request, hold count is decremented by one and when hold count is 0, the resource is unlocked.

47. Difference between ReentrantLock and synchronized.
->  The synchronized keyword is quite rigid in its use. e.g, a thread can take a lock only once.
    Synchronized blocks don’t offer any mechanism of a waiting queue and after the exit of one thread, any thread can
    take the lock. This could lead to starvation of resources for some other thread for a very long period of time.
    ReentrantLock provides a method called lockInterruptibly(), which can be used to interrupt thread when it is waiting
    for lock. Similarly tryLock() with timeout can be used to timeout if lock is not available in certain time period.

    Fairness property provides lock to longest waiting thread, in case of contention. synchronized keyword doesn’t
    support fairness. Any thread can acquire lock once released, no preference can be specified.
    ReentrantLock fair by specifying fairness property, while creating instance of ReentrantLock.

    ReentrantLock provides convenient tryLock() method, which acquires lock only if its available or not held by any
    other thread. This reduce blocking of thread waiting for lock in Java application.
    This is not possible in case of synchronized keyword.

    ReentrantLock also provides convenient method to get List of all threads waiting for lock. We can create different
    conditions for Lock and different thread can await() for different conditions.

    Synchronization code is much cleaner and easy to maintain whereas with Lock we are forced to have try-finally
    block to make sure Lock is released even if some exception is thrown between lock() and unlock() method calls.

    Synchronization blocks or methods can cover only one method whereas we can acquire the lock in one method and
    release it in another method with Lock API.

48. What is ReadWriteLock in Java?
-> In ReadWriteLock multiple thread can perform read operation simultaneously until and unless no thread is performing
write operation, but in case of write only 1 thread is allowed at a time and no other can access the resource.

49. Difference between fair and non-fair locks in ReentrantLock.
->  Fair Reentrant Lock:
    A fair reentrant lock prioritizes threads based on their arrival time. When multiple threads are waiting to acquire
    the lock, the longest-waiting thread is granted access first.
    This ensures a first-come, first-served (FIFO) order of lock acquisition among contending threads.
    Fairness can reduce the risk of thread starvation, where a thread repeatedly loses out on acquiring the lock.
    However, fair locks can sometimes have slightly lower throughput compared to unfair locks due to the overhead
    of maintaining the waiting queue and ensuring strict ordering.

    Unfair Reentrant Lock:
    An unfair reentrant lock does not guarantee any specific order of lock acquisition among waiting threads. When the
    lock becomes available, any of the waiting threads (or even a newly arriving thread) might acquire it,
    regardless of how long they have been waiting.
    Unfair locks generally offer higher throughput because they avoid the overhead associated with maintaining a
    strict queue and can allow for more efficient lock acquisition in certain scenarios, especially when contention
    is low.
    However, unfair locks carry the risk of thread starvation, where a particular thread might repeatedly be
     bypassed by other threads and never acquire the lock.
