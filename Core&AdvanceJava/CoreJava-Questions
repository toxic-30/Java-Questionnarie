1. What are the main principles of Object-Oriented Programming?
-> The 4 main pillars of OOPS are -
   Encapsulation → Binding data + methods, hiding implementation.
   Abstraction → Hiding details, showing essentials (via interfaces/abstract classes).
   Inheritance → Reusing code by acquiring parent properties.
   Polymorphism → One thing, many forms (overloading/overriding).

2. Difference between == and .equals() in Java?
-> == this checks whether 2 string are of same memory location and .equals checks the content of the string.

3. Can you override a static method in Java? Why/why not?
-> No, static method belongs to class, so they are decided at compile time not runtime and its object/instance
   cannot be created

4. Explain constructor overloading vs method overloading.
-> Constructor Overloading = Same class, different constructors → object creation flexibility.
   Method Overloading = Same class, same method name, different params → functional flexibility.

5. What is method overriding and rules for overriding in Java?
-> Method overriding happens when a subclass (child class) provides a specific implementation of a method that is already defined in its parent (superclass).
   It is used to achieve runtime polymorphism (dynamic method dispatch) and to allow a subclass to provide a
   specialized behavior for a parent’s method.
   Rules -
   Same Method Signature - Method name and parameter list must be exactly same as the parent class method.
   Return Type must be the same as parent’s method OR a covariant type (subclass of parent’s return type).
   Access Modifier - Cannot reduce the visibility of the parent’s method. Example: If parent method is public, child
   cannot make it protected or private. But it can increase visibility (e.g., protected → public).
   Exceptions - Child method cannot throw broader checked exceptions than parent. Example: If parent method throws
   IOException, child can throw IOException or subclass of it, but not a broader exception like Exception.
   @Override Annotation - Optional, but useful — compiler will check if you are actually overriding correctly.

6. Difference between final, finally, and finalize().
-> Final - If we mark any class, variable or method as final, so we cannot change it's value.
   so we cannot override the final method and Final class cannot be extended
   Finally is used with try-catch block, it means irrespective of exception, the finally method will execute. So any
   logic which we need to take place after exception also should be kept in finally block.
   Finalize = Method called by GC before object destruction (now deprecated).

7. What is the difference between abstract class and interface?
-> Abstract Class - Can have abstract methods and concrete (implemented) methods.
                    Can have abstract methods, default methods, static and private methods.
                    Method can be public, protected and private.
                    Can extend only 1 abstract class.
                    Can have constructor
   Interface - Can have instance variables, static variables, and constants.
               Only public static final constants (no instance variables)
   	           All methods need to be public.
   	           Can implement multiple interfaces.
               Cannot have constructor

8. Can an abstract class have a constructor?
-> Yes abstract class can have a constructor, to allow its fields to be initialized when subclasses are created.
   You cannot directly create an object of an abstract class

9. Explain the super keyword and its use cases.
-> Super keyword is used in method overriding.
   When a subclass overrides a method, sometimes it still wants to use the parent class’s version of that method.
   That’s where super comes in, it is used to call the overridden method of the parent class.
   Use case - Access parent's class variable and Call parent class constructor.

10. Can we declare a class as both abstract and final? Why not?
->	No, as class is marked abstract so that other class can inherited it, but if it would be declared final so it would
    not be extended.

11. What happens if you don’t provide a constructor in a class?
->  By default every class has constructor, without constructor initialization of class is not possible.

12. Difference between stack and heap memory in Java.
->| Stack Memory                                                                | Heap Memory
  |-----------------------------------------------------------------------------|---------------------------------------------------------------------------
  | Stores method execution details like local variables, references, and calls.| Stores objects and instance variables created at runtime.
  | Automatically allocated/deallocated when a method is called/returns.        | Allocated when `new` keyword is used, freed by Garbage Collector.
  | Local primitive variables Object references (not objects themselves)        | All objects created using `new` nd Instance variables of objects
  | and Method call frames, all these are stored in stack memory                | are stored in heap memory.
  | Exists only during method execution; stack frame removed after method ends. | Objects remain until no reference points to them, then GC clears them.
  | Smaller and fixed per thread.                                               | Larger, depends on JVM and system.
  | Each thread has its own stack.                                              | Heap is shared among all threads.
  | Faster (managed in LIFO order).                                             | Slower (complex memory management + GC).
  | Stack memory overflow → `StackOverflowError`.                               | Heap memory overflow → `OutOfMemoryError: Java Heap Space`.

12. What is the default value of local variables in Java?
->  Local variables do not get any default value. They must be initialized before use, otherwise the compiler will throw an error.

13. Explain pass by value vs pass by reference in Java.
->  Pass by Value - A copy of the variable’s value is passed to the method. Changes inside the method do not affect the
    original variable. Primitive types are always passed by value in Java.
    Pass by Reference - Java is technically never pass by reference

14. What is the use of this keyword?
->  The this keyword in Java refers to the current object. It is mainly used to:
    Differentiate instance variables from local variables.
    Invoke current class methods.
    Call one constructor from another (constructor chaining).
    Pass the current object as an argument.
    Return the current object (useful for method chaining).

15. Difference between shallow copy and deep copy in Java.
->  Shallow copy - Copies the object and references of contained objects (not the actual objects themselves)
    Deep copy - Copies the object and all the objects it references (recursively)

16. Can you create an immutable class? How?
->  Yes, we can create an immutable class. The below given steps need to be followed -
    Declare the class as final. Make all the fields private and final.
    No setter method as it can modify fields. Initialize fields only through constructor.
    For mutable fields - create defensive copy for these fields, also, take a copy in the constructor to avoid outside modification.

17. What is a marker interface? Give examples.
->  A marker interface is an interface that does not have any methods or fields. It is used to mark (tag) a class so
    that the JVM or frameworks can give special treatment to those classes. Basically, it conveys metadata about the
    class to the JVM/compiler.

18. What is the difference between String, StringBuilder, and StringBuffer?
->	String → Immutable, safe to share, but costly in modifications.
    StringBuilder → Mutable, fast, but not synchronized (best in single-threaded apps).
    StringBuffer → Mutable, synchronized, hence thread-safe but slower (used in multi-threaded apps).

19. Why are strings immutable in Java?
->  Security: Strings are widely used in class loading, database URLs, file paths. If mutable, malicious code could change them.
    Caching: String literals are stored in the String Pool. Immutability ensures one object can be shared safely.
    Thread-safety: Immutable objects are automatically thread-safe.
    Hashing: Strings are often used as keys in HashMap/HashSet. Their immutability ensures hashCode remains consistent.

20. What are wrapper classes in Java?
->  A wrapper class is a class that is used to convert a primitive data type into an object. Java provides wrapper
    classes for all primitive types, and they are defined in the java.lang package.

21. Difference between primitive types and reference types.
->  Primitive types store actual values, directly in stack memory (value itself is stored).
    Reference types store addresses (pointers) to objects. The reference(address) is stored in stack, but the actual
    object is stored in heap memory.

22. What is autoboxing and unboxing?
->  Autoboxing is the automatic conversion of a primitive type into its corresponding wrapper class object.
    Unboxing is the automatic conversion of a wrapper class object into its corresponding primitive type.

23. Explain Java memory model.
->

24. Can main() be overloaded in Java?
->  Yes, we can overload the main() method in Java like any other method. But JVM always calls only public static void
    main(String[] args) as the starting point. Other overloaded versions are just normal methods and can only be called
    explicitly.

25. What happens if we make main() non-static?
->  If we make main() non-static, JVM won’t recognize it as the program entry point and runtime error will happen.
    main() must be static so that JVM can invoke it without creating an object.However, we can define a non-static
    main() as an overloaded method, but it must be called explicitly from the static one.

26. What is a static block? When is it executed?
->  A static block in Java is a block of code inside a class, declared using the static keyword.It is used to initialize
    static variables or perform operations that should run once per class loading.

27. Difference between static variable and instance variable.
->  Static variables belong to the class and are shared by all objects. Static variables are initialized once when the
    class is loaded.
    Instance variables belong to the object and each object has its own copy. Instance variables are initialized when
    an object is created.

28. What are default methods in interfaces?
->  A default method is a method in an interface that has a body (implementation), introduced in Java 8. It allows
    interfaces to evolve without breaking existing implementations, and implementing classes can optionally override it.

29. What is multiple inheritance and why is it not supported?
->  Multiple inheritance is a feature where a class can inherit from more than one parent class. It allows a class to
    acquire properties and methods from multiple classes.
    Reasons why multiple inheritance is not allowed -
    Diamond Problem / Ambiguity: If two parent classes have a method with the same signature, the compiler won’t know
    which one to inherit.
    Complexity in object layout: Multiple inheritance complicates memory layout of objects and method dispatch.
    Java prefers simplicity and safety. Instead, it uses interfaces to achieve multiple inheritance.

30. How do interfaces achieve multiple inheritance?
->  Java interfaces allow multiple inheritance by letting a class implement multiple interfaces. Since interfaces define
    only method signatures (and optionally default/static methods), there’s no ambiguity in state or behavior, avoiding
    the diamond problem associated with class inheritance

31. What is the difference between abstract methods and default methods?
->

32. Can we declare an interface method as private?
->  Before Java 9 → No, only public and abstract were allowed.
    From Java 9 onwards → Yes, private methods are allowed inside interfaces but only for internal code reuse
    (not accessible outside).

33. Explain covariant return types.
->  Covariant return type means overridden methods can return a more specific type than the one defined in the parent class.

34. Can you override a private method?
->  No. Private methods are not visible outside the class, hence cannot be overridden. If you declare the same method
    in the subclass, it’s method hiding, not overriding.

35. What is a transient variable in Java?
->  transient keyword marks a variable to be skipped during serialization. When an object is deserialized, transient
    fields are reset to default values.

36. Difference between volatile and transient keywords.
->  volatile: Ensures visibility of changes to a variable across threads. Used in multithreading. Variable is not cached;
    always read from main memory.
    transient: Related to serialization. Prevents a variable from being persisted when an object is serialized.

37. What is the use of strictfp keyword?
->  strictfp (strict floating point) ensures that floating-point calculations are consistent across all platforms.
    Without it, different hardware/OS may give slightly different results. Can be applied to class, method, or interface.

38. Explain the lifecycle of an object in Java.
->  Creation → using new or via reflection, cloning, deserialization.
    In use → object is referenced and accessible.
    Unreachable → no references exist to the object.
    Garbage Collection → JVM identifies unreachable objects.
    Finalization (optional) → finalize() may be called before removal.
    Destruction → object memory reclaimed.

39. Can constructors be synchronized?
->  No. Synchronizing constructors doesn’t make sense because when a constructor runs, the object is not fully created
    yet, so no other thread can access it. However, you can synchronize the code inside the constructor block.

40. What is object cloning in Java?
-> Object cloning means creating a duplicate object with the same state as the original. Done using clone() method of
   Object class. Class must implement Cloneable interface, else CloneNotSupportedException is thrown.

41. How do you prevent object cloning?
42. Difference between deep copy and shallow copy in cloning.

43. What is an inner class? Types of inner classes.
->  An inner class is a class defined inside another class. Types:
    Non-static inner class (regular inner class) - Has access to outer class’s instance members.
    Static nested class - Declared static; cannot access outer class’s instance variables directly.
    Local inner class - Defined inside a block (e.g., method, loop).
    Anonymous inner class - Class without a name, used for instantiating objects with modifications quickly.

44. Difference between static nested class and inner class.
->  | Aspect       | Static Nested Class**                         | Inner (Non-static) Class**
    | -------------| ----------------------------------------------| ------------------------------------------------------------
    | Association  | Does not depend on outer object               | Requires an instance of outer class                          |
    | Access       | Can only access static members of outer class | Can access both static and non-static members of outer class |
    | Instantiation| `Outer.StaticNested obj = new Outer.StaticNested();`| `Outer.Inner obj = new Outer().new Inner();`                 |
    | Memory*      | More memory efficient                              | Needs reference to outer class object                        |

45. Can we define an interface inside a class?
->  Yes, an interface can be declared inside a class or another interface.

46. Explain local inner classes.
-> Local inner class - Defined inside a block (e.g., method, loop). Scope is limited to the block where it’s defined.
   Cannot be declared with access modifiers (public, protected, private) because its visibility is already local to the block.
   Can access: ll members (fields/methods) of the outer class. Final or effectively final local variables of the enclosing block
   Useful for helper classes that are not reused elsewhere.

47. What is an anonymous inner class?
->  Anonymous inner class - Class without a name, used for instantiating objects with modifications quickly.
    It is declared and instantiated in a single expression using new.Usually used to override methods on the fly or
    provide quick implementation of an interface or abstract class.

48. What is a functional interface?
->  A interface is functional interface when it have only 1 abstract method, it can have default and static both.
    but the abstract method should be one and only.

49. Difference between checked and unchecked exceptions.
->  Checked Exceptions - Exceptions that the compiler forces you to either handle with a try-catch block or declare with
    a throws keyword in the method signature.
    Unchecked Exceptions - Exceptions that the compiler does not force you to handle. They usually occur due to
    programming mistakes.

50. Can we catch multiple exceptions in a single catch block?
->  Yes, we can catch multiple exceptions in a single catch block using multi catch feature.

51. Difference between throw and throws.
->  throw-> Used to actually throw an exception. Placed inside method or block. Can throw only one exception at a time
    Followed by an exception object
    throws -> Used to declare exceptions a method might throw. In method signature. Can declare multiple exceptions.
    Followed by exception class names

52. What is try-with-resources in Java?
->  A special try statement that automatically closes resources (like files, DB connections, sockets, etc.) once the
    block finishes — no need for explicit finally.
    Syntax -
    try (ResourceType res = new ResourceType()) {
        // use resource
    } catch (Exception e) {
        // handle exception
    }

53. Can we write multiple finally blocks?
-> No for single try-catch, only 1 finally block is allowed.

53. Difference between error and exception.
->
54. Can we rethrow an exception?
->  Yes. A caught exception can be rethrown using the throw keyword. Useful when you want to log/handle partially and
    then pass it to the caller.

55. Explain custom exceptions in Java.
->  Custom exceptions are user-defined exceptions by extending Exception (checked) or RuntimeException (unchecked). Used
    when built-in exceptions don’t describe the error clearly.
    Syntax -
    class InvalidAgeException extends Exception {
        public InvalidAgeException(String msg) {
            super(msg);
        }
    }

56. What happens if finally block has return statement?
->  If a finally block contains a return statement, it overrides any return value or exception from the try or catch blocks.

57. Can a constructor throw an exception?
->  Yes, a constructor can throw both checked and unchecked exceptions. If a constructor throws a checked exception, it
    must be declared using the throws clause.

58. Difference between compile-time error and runtime error.
->  Compile-time error: Detected by compiler before execution (e.g., syntax errors, type mismatch, missing semicolon).
    Runtime error: Detected while the program is running (e.g., NullPointerException, ArrayIndexOutOfBoundsException).

59. What is the default exception handler in Java?
->  If an exception is not caught/handled in runtime, Java uses the default exception handler
    (ThreadGroup.uncaughtException()) which:-
    Prints the exception name and message.
    Prints the stack trace.
    Terminates the program (if it's the main thread).

60. Explain NoClassDefFoundError vs ClassNotFoundException.
->  NoClassDefFoundError: Occurs when a class was present at compile-time but missing at runtime. It’s an Error.
    ClassNotFoundException: Thrown when an application tries to load a class at runtime using reflection (Class.forName())
    but the class is not found. It’s a checked exception.

61. Explain OutOfMemoryError and how to fix it.
->  OutOfMemoryError: Raised when JVM cannot allocate memory for an object. Causes: Memory leaks, large object creation,
    insufficient heap size.

    How to Fix / Prevent OOME -
    Increase memory limits (temporary solution)
    Fix memory leaks - Use profilers (VisualVM, Eclipse MAT) to check what objects are not being garbage collected.
    Use proper data structures - Example: don’t keep large ArrayList if you only need a few elements.
    Clear unused references (list.clear(), set references to null if long-lived).
    Limit thread creation - Use thread pools (ExecutorService) instead of creating new threads endlessly.
    Tune GC - Use JVM GC options (-XX:+UseG1GC, etc.) for better memory management.

62. Difference between checked exception and runtime exception.
->  Checked exception: Checked at compile time, must be declared or handled. Example: IOException, SQLException.
    Runtime exception: Occurs at runtime, not checked by compiler. Example: NullPointerException, ArithmeticException.

63. What is the difference between throw new Exception() and throw new RuntimeException()?'
->  throw new Exception() → Checked exception → Must be declared with throws or handled in try-catch.
    throw new RuntimeException() → Unchecked exception → No need for declaration, can propagate without handling.

64. Can we create our own Error class?
->  Yes, you can extend Error, but it is not recommended.
    Errors represent serious problems (like JVM crashes, memory issues) that applications shouldn’t try to handle.

65. How does garbage collection work in Java?
->  JVM automatically reclaims memory by collecting objects that are no longer reachable by any live thread or static
    reference.
    GC uses algorithms like Mark-and-Sweep, Generational GC.
    Programmers can request GC via System.gc(), but JVM decides when to run it.
    Finalization (finalize()) is called before object removal (deprecated in newer Java).

66. What are different GC algorithms in Java?
67. Difference between System.gc() and Runtime.gc().
68. Can we force garbage collection in Java?
69. What is finalize() and when is it called?
70. Why is finalize() not recommended?
71. Difference between strong, weak, soft, and phantom references.
72. Explain memory leaks in Java.
73. What are memory pools in JVM?
74. Difference between JDK, JRE, and JVM.
75. Explain Just-In-Time (JIT) compiler.
76. What are classloaders in Java?
77. What is the difference between bootstrap, extension, and application classloader?
78. Explain parent delegation model in classloading.